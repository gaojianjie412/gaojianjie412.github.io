<!DOCTYPE html>
<html lang=en>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="第4章  NumPy基础：数组和矢量计算示例数据存放在GitHub上：http://github.com/pydata/pydata-book 1234567891011121314151617# NumPy本身没有提供多么高级的数据分析功能，理解NumPy数组以及面向数组的计算将有助于更加高效使用诸如Pandas之类# 的工具。因为NumPy是一个很大的题目。附录A中介绍更多高级功能，如广播#">
<meta name="keywords" content="Python,数据分析">
<meta property="og:type" content="article">
<meta property="og:title" content="利用Python进行数据分析.第二版笔记（2）">
<meta property="og:url" content="https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/index.html">
<meta property="og:site_name" content="Robby">
<meta property="og:description" content="第4章  NumPy基础：数组和矢量计算示例数据存放在GitHub上：http://github.com/pydata/pydata-book 1234567891011121314151617# NumPy本身没有提供多么高级的数据分析功能，理解NumPy数组以及面向数组的计算将有助于更加高效使用诸如Pandas之类# 的工具。因为NumPy是一个很大的题目。附录A中介绍更多高级功能，如广播#">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://qiniu.robbyml.com/7178691-78ab11f67e7077a6.png">
<meta property="og:image" content="http://qiniu.robbyml.com/7178691-2f2d7406a8bc076c.png">
<meta property="og:image" content="http://qiniu.robbyml.com/7178691-5cc31115615737b7.png">
<meta property="og:image" content="http://qiniu.robbyml.com/7178691-0a641536f73f560e.png">
<meta property="og:image" content="http://qiniu.robbyml.com/7178691-9da32d2f4629c304.png">
<meta property="og:image" content="http://qiniu.robbyml.com/7178691-1d494e73b61c7ced.png">
<meta property="og:image" content="http://qiniu.robbyml.com/7178691-4e38d02a66481530.png">
<meta property="og:image" content="http://qiniu.robbyml.com/7178691-eff1e61e5464159f.png">
<meta property="og:image" content="https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89_files/%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89_126_1.png">
<meta property="og:image" content="http://qiniu.robbyml.com/7178691-a6c6df3ca8e0b98e.png">
<meta property="og:image" content="http://qiniu.robbyml.com/7178691-866fcde885b1d357.png">
<meta property="og:image" content="http://qiniu.robbyml.com/7178691-80e85ae6b9c89ada.png">
<meta property="og:image" content="http://qiniu.robbyml.com/7178691-dcdb66e49e5f70ea.png">
<meta property="og:image" content="http://qiniu.robbyml.com/7178691-97ba09c96dab93a2.png">
<meta property="og:image" content="http://qiniu.robbyml.com/7178691-97ba09c96dab93a2.png">
<meta property="og:image" content="https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89_files/%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89_196_1.png">
<meta property="og:updated_time" content="2019-11-12T14:50:00.723Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="利用Python进行数据分析.第二版笔记（2）">
<meta name="twitter:description" content="第4章  NumPy基础：数组和矢量计算示例数据存放在GitHub上：http://github.com/pydata/pydata-book 1234567891011121314151617# NumPy本身没有提供多么高级的数据分析功能，理解NumPy数组以及面向数组的计算将有助于更加高效使用诸如Pandas之类# 的工具。因为NumPy是一个很大的题目。附录A中介绍更多高级功能，如广播#">
<meta name="twitter:image" content="http://qiniu.robbyml.com/7178691-78ab11f67e7077a6.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>利用Python进行数据分析.第二版笔记（2）</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/09/22/利用Python进行数据分析.第二版笔记（1）/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/09/18/PicGo-七牛云图床/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&text=利用Python进行数据分析.第二版笔记（2）"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&title=利用Python进行数据分析.第二版笔记（2）"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&is_video=false&description=利用Python进行数据分析.第二版笔记（2）"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=利用Python进行数据分析.第二版笔记（2）&body=Check out this article: https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&title=利用Python进行数据分析.第二版笔记（2）"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&title=利用Python进行数据分析.第二版笔记（2）"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&title=利用Python进行数据分析.第二版笔记（2）"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&title=利用Python进行数据分析.第二版笔记（2）"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&name=利用Python进行数据分析.第二版笔记（2）&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#第4章-NumPy基础：数组和矢量计算"><span class="toc-number">1.</span> <span class="toc-text">第4章  NumPy基础：数组和矢量计算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-NumPy的ndarray-一种多维数组对象"><span class="toc-number">1.1.</span> <span class="toc-text">4.1 NumPy的ndarray:一种多维数组对象</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#创建ndarray"><span class="toc-number">1.1.1.</span> <span class="toc-text">创建ndarray</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ndarray的数据类型"><span class="toc-number">1.1.2.</span> <span class="toc-text">ndarray的数据类型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#NumPy数组的运算"><span class="toc-number">1.1.3.</span> <span class="toc-text">NumPy数组的运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#基本的索引和切片"><span class="toc-number">1.1.4.</span> <span class="toc-text">基本的索引和切片</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#切片索引"><span class="toc-number">1.1.5.</span> <span class="toc-text">切片索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#布尔型索引"><span class="toc-number">1.1.6.</span> <span class="toc-text">布尔型索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#花式索引"><span class="toc-number">1.1.7.</span> <span class="toc-text">花式索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#数组转置和轴对换"><span class="toc-number">1.1.8.</span> <span class="toc-text">数组转置和轴对换</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-通用函数：快速的元素级数组函数"><span class="toc-number">1.2.</span> <span class="toc-text">4.2 通用函数：快速的元素级数组函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-利用数组进行数据处理"><span class="toc-number">1.3.</span> <span class="toc-text">4.3 利用数组进行数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#将条件逻辑表述为数组运算"><span class="toc-number">1.3.1.</span> <span class="toc-text">将条件逻辑表述为数组运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#数学和统计方法"><span class="toc-number">1.3.2.</span> <span class="toc-text">数学和统计方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#用于布尔型数组的方法"><span class="toc-number">1.3.3.</span> <span class="toc-text">用于布尔型数组的方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#排序"><span class="toc-number">1.3.4.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#唯一化以及其它的集合逻辑"><span class="toc-number">1.3.5.</span> <span class="toc-text">唯一化以及其它的集合逻辑</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-用于数组的文件输入输出"><span class="toc-number">1.4.</span> <span class="toc-text">4.4  用于数组的文件输入输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-线性代数"><span class="toc-number">1.5.</span> <span class="toc-text">4.5 线性代数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-伪随机数生成"><span class="toc-number">1.6.</span> <span class="toc-text">4.6 伪随机数生成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-示例：随机漫步"><span class="toc-number">1.7.</span> <span class="toc-text">4.7 示例：随机漫步</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#一次模拟多个随机漫步"><span class="toc-number">1.7.1.</span> <span class="toc-text">一次模拟多个随机漫步</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-8-结论"><span class="toc-number">1.8.</span> <span class="toc-text">4.8 结论</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        利用Python进行数据分析.第二版笔记（2）
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Robby</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-09-21T18:53:22.000Z" itemprop="datePublished">2019-09-22</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/利用Python进行数据分析/">利用Python进行数据分析</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Python/">Python</a>, <a class="tag-link" href="/tags/数据分析/">数据分析</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h4 id="第4章-NumPy基础：数组和矢量计算"><a href="#第4章-NumPy基础：数组和矢量计算" class="headerlink" title="第4章  NumPy基础：数组和矢量计算"></a>第4章  NumPy基础：数组和矢量计算</h4><p>示例数据存放在GitHub上：<a href="http://github.com/pydata/pydata-book">http://github.com/pydata/pydata-book</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NumPy本身没有提供多么高级的数据分析功能，理解NumPy数组以及面向数组的计算将有助于更加高效使用诸如Pandas之类</span></span><br><span class="line"><span class="comment"># 的工具。因为NumPy是一个很大的题目。附录A中介绍更多高级功能，如广播</span></span><br><span class="line"><span class="comment"># 最关注的功能主要集中在：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于数据整理和清理、子集构造和过滤、转换等快速的矢量化数组运算</span></span><br><span class="line"><span class="comment"># 常用的数组算法，如排序、唯一化、集合运算等</span></span><br><span class="line"><span class="comment"># 高效的描述统计和数据聚合/摘要运算。</span></span><br><span class="line"><span class="comment"># 用于异构数据集的合并/连接运算的数据对齐和关系型数据运算。</span></span><br><span class="line"><span class="comment"># 将条件逻辑表述为数组表达式（而不是带有if-elif-else分支的循环）</span></span><br><span class="line"><span class="comment"># 数据的分组运算（聚合、转换、函数应用等）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然NumPy提供了通用的数值数据处理的计算基础，但大多数人还是想将pandas作为统计和分析工作的基础，尤其是</span></span><br><span class="line"><span class="comment"># 处理表格数据时。pandas还有NumPy没有的特定功能，如时间序列等</span></span><br><span class="line"><span class="comment"># NumPy之于数值计算特别重要的原因之一，是因为可以高效处理大数组的数据。因为：</span></span><br><span class="line"><span class="comment"># 1. NumPy是在一个连续的内存块中存储数据，独立于其它Python内置对象。NumPy的C语言编写的算法库可以操作内存，不必</span></span><br><span class="line"><span class="comment"># 进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少</span></span><br><span class="line"><span class="comment"># 2. NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">my_arr = np.arange(<span class="number">1000000</span>)</span><br><span class="line">my_list = list(range(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%time <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>): my_arr2 = my_arr * <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">CPU times: user <span class="number">16.8</span> ms, sys: <span class="number">12.6</span> ms, total: <span class="number">29.4</span> ms</span><br><span class="line">Wall time: <span class="number">28.7</span> ms</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%time <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>): my_list2 = [x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> my_list]</span><br><span class="line">  </span><br><span class="line">CPU times: user <span class="number">551</span> ms, sys: <span class="number">183</span> ms, total: <span class="number">734</span> ms</span><br><span class="line">Wall time: <span class="number">737</span> ms</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于NumPy的算法要比纯Python快10到100倍（甚至更快），并且使用内存更少</span></span><br></pre></td></tr></table></figure>

<h5 id="4-1-NumPy的ndarray-一种多维数组对象"><a href="#4-1-NumPy的ndarray-一种多维数组对象" class="headerlink" title="4.1 NumPy的ndarray:一种多维数组对象"></a>4.1 NumPy的ndarray:一种多维数组对象</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NumPy最重要的一个特点就是其N维数组对象（即ndarray），该对象是一个快速而灵活的大数据集容器。可以利用这种</span></span><br><span class="line"><span class="comment"># 数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = np.random.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">data</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">0.19787863</span>,  <span class="number">0.64832134</span>,  <span class="number">1.69508236</span>],</span><br><span class="line">       [<span class="number">-0.48421838</span>, <span class="number">-2.40216949</span>,  <span class="number">0.26746769</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data * <span class="number">10</span></span><br><span class="line"></span><br><span class="line">array([[  <span class="number">1.97878629</span>,   <span class="number">6.48321345</span>,  <span class="number">16.95082362</span>],</span><br><span class="line">       [ <span class="number">-4.8421838</span> , <span class="number">-24.02169487</span>,   <span class="number">2.67467692</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data + data</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">0.39575726</span>,  <span class="number">1.29664269</span>,  <span class="number">3.39016472</span>],</span><br><span class="line">       [<span class="number">-0.96843676</span>, <span class="number">-4.80433897</span>,  <span class="number">0.53493538</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ndarray是一个通用的同构数据多维容器，也就是说，其中的所有元素必须是相同类型。每个数组都有一个shape（表示</span></span><br><span class="line"><span class="comment"># 各维度大小的元祖）和一个dtype(用于说明数组数据类型的对象)</span></span><br><span class="line">data.shape</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.dtype</span><br><span class="line"></span><br><span class="line">dtype(<span class="string">'float64'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本书中看到“数组”、“NumPy数组”、“ndarray”时，基本上都是指ndarray对象</span></span><br></pre></td></tr></table></figure>

<h6 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数组最简单的办法就是使用array函数。它接受一切序列型对象（包括其它数组），然后产生一个新的含有传入数据的</span></span><br><span class="line"><span class="comment"># NumPy数组。以一个列表的转换为例：</span></span><br><span class="line">data1 = [<span class="number">6</span>,<span class="number">7.5</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">arr1 = np.array(data1)</span><br><span class="line">arr1</span><br><span class="line"></span><br><span class="line">array([<span class="number">6.</span> , <span class="number">7.5</span>, <span class="number">8.</span> , <span class="number">0.</span> , <span class="number">1.</span> ])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 嵌套序列（比如由一组等长列表组成的列表）将会被转换为一个多维数组：</span></span><br><span class="line">data2 = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">arr2 = np.array(data2)</span><br><span class="line">arr2</span><br><span class="line"></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为data2是列表的列表，NumPy数组arr2的两个维度的shape是从data2引入的。可以用属性ndim和shape验证：</span></span><br><span class="line">arr2.ndim</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr2.shape</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 除非特别说明，np.array会尝试为新建的这个数组推断出一个较为合适的数据类型。数据类型保存在一个特殊的dtype</span></span><br><span class="line"><span class="comment"># 对象中。比如说，在上面的两个例子中，我们有：</span></span><br><span class="line">arr1.dtype</span><br><span class="line"></span><br><span class="line">dtype(<span class="string">'float64'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr2.dtype</span><br><span class="line"></span><br><span class="line">dtype(<span class="string">'int64'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 除了np.array之外，还有一些函数也可以新建数组。比如，zeros和ones分别可以创建指定长度或形状全0或全1数组。</span></span><br><span class="line"><span class="comment"># empty可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需传入一个表示形状的元祖即可：</span></span><br><span class="line">np.zeros(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">array([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.zeros((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">np.empty((<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">array([[[<span class="number">7.4e-323</span>, <span class="number">0.0e+000</span>],</span><br><span class="line">        [<span class="number">0.0e+000</span>, <span class="number">0.0e+000</span>],</span><br><span class="line">        [<span class="number">0.0e+000</span>, <span class="number">0.0e+000</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">0.0e+000</span>, <span class="number">0.0e+000</span>],</span><br><span class="line">        [<span class="number">0.0e+000</span>, <span class="number">0.0e+000</span>],</span><br><span class="line">        [<span class="number">0.0e+000</span>, <span class="number">0.0e+000</span>]]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：认为np.empty会返回全0数组的想法是不安全的。很多情况下（如前所示），它返回的都是一些未初始化的垃圾值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arange是Python内置函数range的数组版</span></span><br><span class="line">np.arange(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出了一些数组创建函数。NumPy关注的是数值计算，没有特别指定，数据类型都是float64(浮点数)</span></span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.robbyml.com/7178691-78ab11f67e7077a6.png" alt></p>
<h6 id="ndarray的数据类型"><a href="#ndarray的数据类型" class="headerlink" title="ndarray的数据类型"></a>ndarray的数据类型</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息：</span></span><br><span class="line">arr1 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],dtype = np.float64)</span><br><span class="line">arr2 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],dtype=np.int32)</span><br><span class="line">arr1.dtype</span><br><span class="line"></span><br><span class="line">dtype(<span class="string">'float64'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr2.dtype</span><br><span class="line"></span><br><span class="line">dtype(<span class="string">'int32'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dtype是NumPy灵活交互其它系统的源泉之一。多数情况，他们直接映射到相应的机器表示，这使得“读写磁盘上的二进制数据流”</span></span><br><span class="line"><span class="comment"># 以及“集成低级语言代码（如C、Fortran）”等工作变得更加简单。数值型dtype的命名方式相同：一个类型名（如float或int）</span></span><br><span class="line"><span class="comment"># 后面跟一个用于表示各元素位长的数字。标准的双精度浮点值（即Python中的float对象）需要占用8字节（即64位）</span></span><br><span class="line"><span class="comment"># 因此，该类型在NumPy中就记作float64。下面表中列出了NumPy所支持的全部数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记不住这些NumPy的dtype也没关系，新手更是如此。通常只需要知道你所处理的数据的大致类型是浮点数、复数、整数、</span></span><br><span class="line"><span class="comment"># 布尔值、字符串，还是普通的Python对象即可。当你需要控制数据在内存和磁盘中的存储方式时（尤其是对大数据集），</span></span><br><span class="line"><span class="comment"># 那就得了解如何控制存储类型。</span></span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.robbyml.com/7178691-2f2d7406a8bc076c.png" alt></p>
<p><img src="http://qiniu.robbyml.com/7178691-5cc31115615737b7.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你可以通过ndarray的astype方法明确地将一个数组从一个dtype转换成另一个dtype：</span></span><br><span class="line">arr = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">arr.dtype</span><br><span class="line"></span><br><span class="line">dtype(<span class="string">'int64'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float_arr = arr.astype(np.float64)</span><br><span class="line">float_arr.dtype</span><br><span class="line"></span><br><span class="line">dtype(<span class="string">'float64'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本例中，整数被转换成了浮点数。如果将浮点数转换成整数，则小数部分将会被截取删除：</span></span><br><span class="line">arr = np.array([<span class="number">3.7</span>,<span class="number">-1.2</span>,<span class="number">-2.6</span>,<span class="number">0.5</span>,<span class="number">12.9</span>,<span class="number">10.1</span>])</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([ <span class="number">3.7</span>, <span class="number">-1.2</span>, <span class="number">-2.6</span>,  <span class="number">0.5</span>, <span class="number">12.9</span>, <span class="number">10.1</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.astype(np.int32)</span><br><span class="line"></span><br><span class="line">array([ <span class="number">3</span>, <span class="number">-1</span>, <span class="number">-2</span>,  <span class="number">0</span>, <span class="number">12</span>, <span class="number">10</span>], dtype=int32)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式：</span></span><br><span class="line">numeric_string = np.array([<span class="string">'1.25'</span>,<span class="string">'-9.6'</span>,<span class="string">'42'</span>],dtype=np.string_)</span><br><span class="line">numeric_string.astype(np.float)</span><br><span class="line"></span><br><span class="line">array([ <span class="number">1.25</span>, <span class="number">-9.6</span> , <span class="number">42.</span>  ])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：使用numpy.string_类型时，一定要小心，因为NumPy的字符串数据是大小固定的，发生截取时，不会发出警告。</span></span><br><span class="line"><span class="comment"># pandas提供了更多非数值数据的便利的处理方法。</span></span><br><span class="line"><span class="comment"># 如果转换过程因为某种原因而失败了（比如某个不能被转换为float64的字符串），就会引发一个ValueError。这里，我比较懒，</span></span><br><span class="line"><span class="comment"># 写的是float而不是np.float64；NumPy很聪明，它会将Python类型映射到等价的dtype上。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组的dtype还有另一个属性：</span></span><br><span class="line">empty_uint32 = np.empty(<span class="number">8</span>,dtype=<span class="string">'u4'</span>)</span><br><span class="line">empty_uint32</span><br><span class="line"></span><br><span class="line">array([         <span class="number">0</span>, <span class="number">1075314688</span>,          <span class="number">0</span>, <span class="number">1075707904</span>,          <span class="number">0</span>,</span><br><span class="line">       <span class="number">1075838976</span>,          <span class="number">0</span>, <span class="number">1072693248</span>], dtype=uint32)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 笔记：调用astype总会创建一个新的数组（一个数据的备份），即使新的dtype与旧的dtype相同。</span></span><br></pre></td></tr></table></figure>

<h6 id="NumPy数组的运算"><a href="#NumPy数组的运算" class="headerlink" title="NumPy数组的运算"></a>NumPy数组的运算</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组很重要，因为它使你不用编写循环即可对数据执行批量运算。NumPy用户称其为矢量化（vectorization）。</span></span><br><span class="line"><span class="comment"># 大小相等的数组之间的任何算术运算都会将运算应用到元素级：</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>],[<span class="number">4.</span>,<span class="number">5.</span>,<span class="number">6.</span>]])</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr * arr</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">9.</span>],</span><br><span class="line">       [<span class="number">16.</span>, <span class="number">25.</span>, <span class="number">36.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr - arr</span><br><span class="line"></span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组与标量的算术运算会将标量值传播到各个元素：</span></span><br><span class="line"><span class="number">1</span>/arr</span><br><span class="line"></span><br><span class="line">array([[<span class="number">1.</span>        , <span class="number">0.5</span>       , <span class="number">0.33333333</span>],</span><br><span class="line">       [<span class="number">0.25</span>      , <span class="number">0.2</span>       , <span class="number">0.16666667</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr * <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">array([[<span class="number">0.5</span>, <span class="number">1.</span> , <span class="number">1.5</span>],</span><br><span class="line">       [<span class="number">2.</span> , <span class="number">2.5</span>, <span class="number">3.</span> ]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大小相同的数组之间的比较会生成布尔值数组：</span></span><br><span class="line">arr2 = np.array([[<span class="number">0.</span>,<span class="number">4.</span>,<span class="number">1.</span>],[<span class="number">7.</span>,<span class="number">2.</span>,<span class="number">12.</span>]])</span><br><span class="line">arr2</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">4.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">7.</span>,  <span class="number">2.</span>, <span class="number">12.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr2 &gt; arr</span><br><span class="line"></span><br><span class="line">array([[<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不同大小的数组之间的运算叫做广播（broadcasting），将在附录A中对其进行详细讨论。</span></span><br><span class="line"><span class="comment"># 本书的内容不需要对广播机制有多深的理解。</span></span><br></pre></td></tr></table></figure>

<h6 id="基本的索引和切片"><a href="#基本的索引和切片" class="headerlink" title="基本的索引和切片"></a>基本的索引和切片</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NumPy数组的索引是一个内容丰富的主题，因为选取数据子集或单个元素的方式有很多。一维数组很简单。</span></span><br><span class="line"><span class="comment"># 从表面上看，它们跟Python列表的功能差不多：</span></span><br><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">5</span>:<span class="number">8</span>] = <span class="number">12</span></span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>,  <span class="number">8</span>,  <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如上所示，当你将一个标量值赋值给一个切片时（如arr[5:8]=12），该值会自动传播（也就说后面将会讲到的“广播”）</span></span><br><span class="line"><span class="comment"># 到整个选区。跟列表最重要的区别在于，数组切片是原始数组的视图。这意味着数据不会被复制，视图上的任何修改都会直接</span></span><br><span class="line"><span class="comment"># 反映到源数组上。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 作为例子，先创建一个arr的切片：</span></span><br><span class="line">arr_slice = arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">arr_slice</span><br><span class="line"></span><br><span class="line">array([<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现在，当我修稿arr_slice中的值，变动也会体现在原始数组arr中：</span></span><br><span class="line">arr_slice[<span class="number">1</span>] = <span class="number">12345</span></span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([    <span class="number">0</span>,     <span class="number">1</span>,     <span class="number">2</span>,     <span class="number">3</span>,     <span class="number">4</span>,    <span class="number">12</span>, <span class="number">12345</span>,    <span class="number">12</span>,     <span class="number">8</span>,</span><br><span class="line">           <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切片[ : ]会给数组中的所有值赋值：</span></span><br><span class="line">arr_slice[:] = <span class="number">64</span></span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>,  <span class="number">8</span>,  <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你刚开始接触NumPy，可能会对此感到惊讶（尤其是当你曾经用过其他热衷于复制数组数据的编程语言）。由于NumPy的</span></span><br><span class="line"><span class="comment"># 设计目的是处理大数据，所以你可以想象一下，假如NumPy坚持要将数据复制来复制去的话会产生何等的性能和内存问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：如果你想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作，例如arr[5:8].copy()。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于高维度数组，能做的事情更多。在一个二维数组中，各索引位置上的元素不再是标量而是一维数组：</span></span><br><span class="line">arr2d = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">arr2d[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因此，可以对各个元素进行递归访问，但这样需要做的事情有点多。你可以传入一个以逗号隔开的索引列表来选取单个元素。</span></span><br><span class="line"><span class="comment"># 也就是说，下面两种方式是等价的：</span></span><br><span class="line">arr2d[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr2d[<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下图说明了二维数组的索引方式。轴0作为行，轴1作为列。</span></span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.robbyml.com/7178691-0a641536f73f560e.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在多维数组中，如果省略了后面的索引，则返回对象会是一个维度低一点的ndarray（它含有高一级维度上的所有数据）。</span></span><br><span class="line"><span class="comment"># 因此，在2×2×3数组arr3d中：</span></span><br><span class="line">arr3d = np.array([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]],[[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]])</span><br><span class="line">arr3d</span><br><span class="line"></span><br><span class="line">array([[[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arr3d[0]是一个2×3数组：</span></span><br><span class="line">arr3d[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标量值和数组都可以被赋值给arr3d[0]:</span></span><br><span class="line">old_values = arr3d[<span class="number">0</span>].copy()</span><br><span class="line">arr3d[<span class="number">0</span>] = <span class="number">42</span></span><br><span class="line">arr3d</span><br><span class="line"></span><br><span class="line">array([[[<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>],</span><br><span class="line">        [<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr3d[<span class="number">0</span>] = old_values</span><br><span class="line">arr3d</span><br><span class="line"></span><br><span class="line">array([[[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相似的，arr3d[1,0]可以访问索引以(1,0)开头的那些值（以一维数组的形式返回）：</span></span><br><span class="line">arr3d[<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，在上面所有这些选取数组子集的例子中，返回的数组都是视图。</span></span><br></pre></td></tr></table></figure>

<h6 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ndarray的切片语法跟Python列表这样的一维对象差不多：</span></span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>,  <span class="number">8</span>,  <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">1</span>:<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">array([ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">64</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于之前的二维数组arr2d，其切片方式稍显不同：</span></span><br><span class="line">arr2d</span><br><span class="line"></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr2d[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以看出，它是沿着第0轴（即第一个轴）切片的。也就是说，切片是沿着一个轴向选取元素的。</span></span><br><span class="line"><span class="comment"># 表达式arr2d[:2]可以被认为是“选取arr2d的前两行”。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你可以一次传入多个切片，就像传入多个索引那样：</span></span><br><span class="line">arr2d[:<span class="number">2</span>,<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">array([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 像这样进行切片时，只能得到相同维数的数组视图。通过将整数索引和切片混合，可以得到低维度的切片。</span></span><br><span class="line"><span class="comment"># 例如，我可以选取第二行的前两列：</span></span><br><span class="line">arr2d[<span class="number">1</span>,:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">array([<span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相似的，还可以选择第三列的前两行：</span></span><br><span class="line">arr2d[:<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">array([<span class="number">3</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下图对此进行了说明。注意，“只有冒号”表示选取整个轴，因此你可以像下面这样只对高维轴进行切片：</span></span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.robbyml.com/7178691-9da32d2f4629c304.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自然，对切片表达式的赋值操作也会被扩散到整个选区：</span></span><br><span class="line">arr2d[:<span class="number">2</span>,<span class="number">1</span>:] = <span class="number">0</span></span><br><span class="line">arr2d</span><br><span class="line"></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>

<h6 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 来看这样一个例子，假设我们有一个用于存储数据的数组以及一个存储姓名的数组（含有重复项）。在这里，</span></span><br><span class="line"><span class="comment"># 我将使用numpy.random中的randn函数生成一些正态分布的随机数据：</span></span><br><span class="line">names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</span><br><span class="line">data = np.random.randn(<span class="number">7</span>,<span class="number">4</span>)</span><br><span class="line">names</span><br><span class="line"></span><br><span class="line">array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>], dtype=<span class="string">'&lt;U4'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data</span><br><span class="line"></span><br><span class="line">array([[<span class="number">-0.82755717</span>,  <span class="number">1.918534</span>  , <span class="number">-0.57450826</span>, <span class="number">-0.2432468</span> ],</span><br><span class="line">       [<span class="number">-0.46462167</span>,  <span class="number">0.3754154</span> ,  <span class="number">0.86647801</span>, <span class="number">-0.90242375</span>],</span><br><span class="line">       [ <span class="number">0.76724713</span>, <span class="number">-0.69173302</span>,  <span class="number">1.07177289</span>,  <span class="number">0.03736848</span>],</span><br><span class="line">       [ <span class="number">1.19604303</span>, <span class="number">-0.88936164</span>,  <span class="number">0.47709256</span>,  <span class="number">0.24233634</span>],</span><br><span class="line">       [<span class="number">-0.33257435</span>, <span class="number">-0.31687058</span>, <span class="number">-1.55772174</span>, <span class="number">-0.03396955</span>],</span><br><span class="line">       [<span class="number">-1.51042354</span>,  <span class="number">1.2993217</span> , <span class="number">-0.52354819</span>,  <span class="number">0.744926</span>  ],</span><br><span class="line">       [ <span class="number">0.97377054</span>, <span class="number">-2.03288979</span>, <span class="number">-0.17015768</span>,  <span class="number">0.80907519</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设每个名字都对应data数组中的一行，而我们想要选出对应于名字"Bob"的所有行。跟算术运算一样，数组的比较运算</span></span><br><span class="line"><span class="comment"># （如==）也是矢量化的。因此，对names和字符串"Bob"的比较运算将会产生一个布尔型数组：</span></span><br><span class="line">names == <span class="string">'Bob'</span></span><br><span class="line"></span><br><span class="line">array([ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个布尔型数组可用于数组索引：</span></span><br><span class="line">data[names==<span class="string">'Bob'</span>]</span><br><span class="line"></span><br><span class="line">array([[<span class="number">-0.82755717</span>,  <span class="number">1.918534</span>  , <span class="number">-0.57450826</span>, <span class="number">-0.2432468</span> ],</span><br><span class="line">       [ <span class="number">1.19604303</span>, <span class="number">-0.88936164</span>,  <span class="number">0.47709256</span>,  <span class="number">0.24233634</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 布尔型数组的长度必须跟被索引的轴长度一致。此外，还可以将布尔型数组跟切片、整数（或整数序列，稍后将对此进行</span></span><br><span class="line"><span class="comment"># 详细讲解）混合使用：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：如果布尔型数组的长度不对，布尔型选择就会出错，因此一定要小心。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的例子，我选取了names == 'Bob'的行，并索引了列</span></span><br><span class="line">data[names==<span class="string">'Bob'</span>,<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">array([[<span class="number">-0.57450826</span>, <span class="number">-0.2432468</span> ],</span><br><span class="line">       [ <span class="number">0.47709256</span>,  <span class="number">0.24233634</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[names==<span class="string">'Bob'</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">array([<span class="number">-0.2432468</span> ,  <span class="number">0.24233634</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要选择除"Bob"以外的其他值，既可以使用不等于符号（!=），也可以通过~对条件进行否定：</span></span><br><span class="line">names != <span class="string">'Bob'</span></span><br><span class="line"></span><br><span class="line">array([<span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data[~(names == <span class="string">'Bob'</span>)]</span><br><span class="line"></span><br><span class="line">array([[<span class="number">-0.46462167</span>,  <span class="number">0.3754154</span> ,  <span class="number">0.86647801</span>, <span class="number">-0.90242375</span>],</span><br><span class="line">       [ <span class="number">0.76724713</span>, <span class="number">-0.69173302</span>,  <span class="number">1.07177289</span>,  <span class="number">0.03736848</span>],</span><br><span class="line">       [<span class="number">-0.33257435</span>, <span class="number">-0.31687058</span>, <span class="number">-1.55772174</span>, <span class="number">-0.03396955</span>],</span><br><span class="line">       [<span class="number">-1.51042354</span>,  <span class="number">1.2993217</span> , <span class="number">-0.52354819</span>,  <span class="number">0.744926</span>  ],</span><br><span class="line">       [ <span class="number">0.97377054</span>, <span class="number">-2.03288979</span>, <span class="number">-0.17015768</span>,  <span class="number">0.80907519</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~操作符用来反转条件很好用：</span></span><br><span class="line">cond = names == <span class="string">'Bob'</span></span><br><span class="line">data[~cond]</span><br><span class="line"></span><br><span class="line">array([[<span class="number">-0.46462167</span>,  <span class="number">0.3754154</span> ,  <span class="number">0.86647801</span>, <span class="number">-0.90242375</span>],</span><br><span class="line">       [ <span class="number">0.76724713</span>, <span class="number">-0.69173302</span>,  <span class="number">1.07177289</span>,  <span class="number">0.03736848</span>],</span><br><span class="line">       [<span class="number">-0.33257435</span>, <span class="number">-0.31687058</span>, <span class="number">-1.55772174</span>, <span class="number">-0.03396955</span>],</span><br><span class="line">       [<span class="number">-1.51042354</span>,  <span class="number">1.2993217</span> , <span class="number">-0.52354819</span>,  <span class="number">0.744926</span>  ],</span><br><span class="line">       [ <span class="number">0.97377054</span>, <span class="number">-2.03288979</span>, <span class="number">-0.17015768</span>,  <span class="number">0.80907519</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选取这三个名字中的两个需要组合应用多个布尔条件，使用&amp;（和）、|（或）之类的布尔算术运算符即可：</span></span><br><span class="line">mask = (names == <span class="string">'Bob'</span>) | (names == <span class="string">'Will'</span>)</span><br><span class="line">mask</span><br><span class="line"></span><br><span class="line">array([ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data[mask]</span><br><span class="line"></span><br><span class="line">array([[<span class="number">-0.82755717</span>,  <span class="number">1.918534</span>  , <span class="number">-0.57450826</span>, <span class="number">-0.2432468</span> ],</span><br><span class="line">       [ <span class="number">0.76724713</span>, <span class="number">-0.69173302</span>,  <span class="number">1.07177289</span>,  <span class="number">0.03736848</span>],</span><br><span class="line">       [ <span class="number">1.19604303</span>, <span class="number">-0.88936164</span>,  <span class="number">0.47709256</span>,  <span class="number">0.24233634</span>],</span><br><span class="line">       [<span class="number">-0.33257435</span>, <span class="number">-0.31687058</span>, <span class="number">-1.55772174</span>, <span class="number">-0.03396955</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此。</span></span><br><span class="line"><span class="comment"># 注意：Python关键字and和or在布尔型数组中无效。要使用&amp;与|。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过布尔型数组设置值是一种经常用到的手段。为了将data中的所有负值都设置为0，我们只需：</span></span><br><span class="line">data[data &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">data</span><br><span class="line"></span><br><span class="line">array([[<span class="number">0.</span>        , <span class="number">1.918534</span>  , <span class="number">0.</span>        , <span class="number">0.</span>        ],</span><br><span class="line">       [<span class="number">0.</span>        , <span class="number">0.3754154</span> , <span class="number">0.86647801</span>, <span class="number">0.</span>        ],</span><br><span class="line">       [<span class="number">0.76724713</span>, <span class="number">0.</span>        , <span class="number">1.07177289</span>, <span class="number">0.03736848</span>],</span><br><span class="line">       [<span class="number">1.19604303</span>, <span class="number">0.</span>        , <span class="number">0.47709256</span>, <span class="number">0.24233634</span>],</span><br><span class="line">       [<span class="number">0.</span>        , <span class="number">0.</span>        , <span class="number">0.</span>        , <span class="number">0.</span>        ],</span><br><span class="line">       [<span class="number">0.</span>        , <span class="number">1.2993217</span> , <span class="number">0.</span>        , <span class="number">0.744926</span>  ],</span><br><span class="line">       [<span class="number">0.97377054</span>, <span class="number">0.</span>        , <span class="number">0.</span>        , <span class="number">0.80907519</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过一维布尔数组设置整行或列的值也很简单：</span></span><br><span class="line">data[names != <span class="string">'Joe'</span>] = <span class="number">7</span></span><br><span class="line">data</span><br><span class="line"></span><br><span class="line">array([[<span class="number">7.</span>        , <span class="number">7.</span>        , <span class="number">7.</span>        , <span class="number">7.</span>        ],</span><br><span class="line">       [<span class="number">0.</span>        , <span class="number">0.3754154</span> , <span class="number">0.86647801</span>, <span class="number">0.</span>        ],</span><br><span class="line">       [<span class="number">7.</span>        , <span class="number">7.</span>        , <span class="number">7.</span>        , <span class="number">7.</span>        ],</span><br><span class="line">       [<span class="number">7.</span>        , <span class="number">7.</span>        , <span class="number">7.</span>        , <span class="number">7.</span>        ],</span><br><span class="line">       [<span class="number">7.</span>        , <span class="number">7.</span>        , <span class="number">7.</span>        , <span class="number">7.</span>        ],</span><br><span class="line">       [<span class="number">0.</span>        , <span class="number">1.2993217</span> , <span class="number">0.</span>        , <span class="number">0.744926</span>  ],</span><br><span class="line">       [<span class="number">0.97377054</span>, <span class="number">0.</span>        , <span class="number">0.</span>        , <span class="number">0.80907519</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后面会看到，这类二维数据的操作也可以用pandas方便的来做。</span></span><br></pre></td></tr></table></figure>

<h6 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 花式索引（Fancy indexing）是一个NumPy术语，它指的是利用整数数组进行索引。假设我们有一个8×4数组：</span></span><br><span class="line">arr = np.empty((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    arr[i] = i</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">       [<span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>],</span><br><span class="line">       [<span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">       [<span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或ndarray即可：</span></span><br><span class="line">arr[[<span class="number">4</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">array([[<span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这段代码确实达到我们的要求了！使用负数索引将会从末尾开始选取行：</span></span><br><span class="line">arr[[<span class="number">-3</span>,<span class="number">-5</span>,<span class="number">-7</span>]]</span><br><span class="line"></span><br><span class="line">array([[<span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一次传入多个索引数组会有一点特别。它返回的是一个一维数组，其中的元素对应各个索引元组：</span></span><br><span class="line">arr = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">       [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">       [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>],</span><br><span class="line">       [<span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[[<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">array([ <span class="number">4</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 附录A中会详细介绍reshape方法。</span></span><br><span class="line"><span class="comment"># 最终选出的是元素(1,0)、(5,3)、(7,1)和(2,2)。无论数组是多少维的，花式索引总是一维的。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个花式索引的行为可能会跟某些用户的预期不一样（包括我在内），选取矩阵的行列子集应该是矩形区域的形式才对。</span></span><br><span class="line"><span class="comment"># 下面是得到该结果的一个办法：</span></span><br><span class="line">arr[[<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>]][:,[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">7</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">22</span>],</span><br><span class="line">       [<span class="number">28</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">11</span>,  <span class="number">9</span>, <span class="number">10</span>]])</span><br></pre></td></tr></table></figure>

<h6 id="数组转置和轴对换"><a href="#数组转置和轴对换" class="headerlink" title="数组转置和轴对换"></a>数组转置和轴对换</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转置是重塑的一种特殊形式，它返回的是源数据的视图（不会进行任何复制操作）。数组不仅有transpose方法，</span></span><br><span class="line"><span class="comment"># 还有一个特殊的T属性：</span></span><br><span class="line">arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>,<span class="number">5</span>))</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr.T</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">5</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">6</span>, <span class="number">11</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">7</span>, <span class="number">12</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">8</span>, <span class="number">13</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">9</span>, <span class="number">14</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在进行矩阵计算时，经常需要用到该操作，比如利用np.dot计算矩阵内积：</span></span><br><span class="line">arr = np.random.randn(<span class="number">6</span>,<span class="number">3</span>)</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([[<span class="number">-0.43915094</span>,  <span class="number">1.00519567</span>,  <span class="number">0.09349</span>   ],</span><br><span class="line">       [ <span class="number">1.25687745</span>,  <span class="number">0.86939274</span>, <span class="number">-0.23435455</span>],</span><br><span class="line">       [ <span class="number">2.09902022</span>, <span class="number">-0.34193719</span>, <span class="number">-0.28231765</span>],</span><br><span class="line">       [<span class="number">-1.2859984</span> , <span class="number">-0.05913956</span>,  <span class="number">1.20293862</span>],</span><br><span class="line">       [<span class="number">-0.3057062</span> ,  <span class="number">0.51809959</span>, <span class="number">-0.17810376</span>],</span><br><span class="line">       [ <span class="number">1.68126911</span>,  <span class="number">1.22524681</span>,  <span class="number">1.48441102</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.dot(arr.T,arr)</span><br><span class="line"></span><br><span class="line">array([[<span class="number">10.75239432</span>,  <span class="number">1.91119114</span>,  <span class="number">0.07496305</span>],</span><br><span class="line">       [ <span class="number">1.91119114</span>,  <span class="number">3.65633752</span>,  <span class="number">1.64211763</span>],</span><br><span class="line">       [ <span class="number">0.07496305</span>,  <span class="number">1.64211763</span>,  <span class="number">3.82562405</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置（比较费脑子）：</span></span><br><span class="line">arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr.transpose((<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里，第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单的转置可以使用.T，它其实就是进行轴对换而已。ndarray还有一个swapaxes方法，它需要接受一对轴编号：</span></span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr.swapaxes(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">1</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">2</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">13</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">14</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">15</span>]]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># swapaxes也是返回源数据的视图（不会进行任何复制操作）。</span></span><br></pre></td></tr></table></figure>

<h5 id="4-2-通用函数：快速的元素级数组函数"><a href="#4-2-通用函数：快速的元素级数组函数" class="headerlink" title="4.2 通用函数：快速的元素级数组函数"></a>4.2 通用函数：快速的元素级数组函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。你可以将其看做简单函数</span></span><br><span class="line"><span class="comment"># （接受一个或多个标量值，并产生一个或多个标量值）的矢量化包装器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 许多ufunc都是简单的元素级变体，如sqrt和exp：</span></span><br><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(arr)</span><br><span class="line"></span><br><span class="line">array([<span class="number">0.</span>        , <span class="number">1.</span>        , <span class="number">1.41421356</span>, <span class="number">1.73205081</span>, <span class="number">2.</span>        ,</span><br><span class="line">       <span class="number">2.23606798</span>, <span class="number">2.44948974</span>, <span class="number">2.64575131</span>, <span class="number">2.82842712</span>, <span class="number">3.</span>        ])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.exp(arr)</span><br><span class="line"></span><br><span class="line">array([<span class="number">1.00000000e+00</span>, <span class="number">2.71828183e+00</span>, <span class="number">7.38905610e+00</span>, <span class="number">2.00855369e+01</span>,</span><br><span class="line">       <span class="number">5.45981500e+01</span>, <span class="number">1.48413159e+02</span>, <span class="number">4.03428793e+02</span>, <span class="number">1.09663316e+03</span>,</span><br><span class="line">       <span class="number">2.98095799e+03</span>, <span class="number">8.10308393e+03</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这些都是一元（unary）ufunc。另外一些（如add或maximum）接受2个数组（因此也叫二元（binary）ufunc），</span></span><br><span class="line"><span class="comment"># 并返回一个结果数组：</span></span><br><span class="line">x = np.random.randn(<span class="number">8</span>)</span><br><span class="line">y = np.random.randn(<span class="number">8</span>)</span><br><span class="line">x</span><br><span class="line"></span><br><span class="line">array([<span class="number">-1.3402239</span> ,  <span class="number">0.06988682</span>,  <span class="number">1.04888669</span>,  <span class="number">0.09447717</span>, <span class="number">-0.06758911</span>,</span><br><span class="line">        <span class="number">0.59909506</span>, <span class="number">-0.09615231</span>,  <span class="number">1.59586139</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y</span><br><span class="line"></span><br><span class="line">array([ <span class="number">0.62177978</span>,  <span class="number">1.64087729</span>, <span class="number">-0.42898854</span>,  <span class="number">0.36091111</span>,  <span class="number">0.21355336</span>,</span><br><span class="line">       <span class="number">-1.76299042</span>, <span class="number">-0.20088516</span>, <span class="number">-2.13645066</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.maximum(x,y)</span><br><span class="line"></span><br><span class="line">array([ <span class="number">0.62177978</span>,  <span class="number">1.64087729</span>,  <span class="number">1.04888669</span>,  <span class="number">0.36091111</span>,  <span class="number">0.21355336</span>,</span><br><span class="line">        <span class="number">0.59909506</span>, <span class="number">-0.09615231</span>,  <span class="number">1.59586139</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里，numpy.maximum计算了x和y中元素级别最大的元素。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 虽然并不常见，但有些ufunc的确可以返回多个数组。modf就是一个例子，它是Python内置函数divmod的矢量化版本，</span></span><br><span class="line"><span class="comment"># 它会返回浮点数数组的小数和整数部分：</span></span><br><span class="line">arr = np.random.randn(<span class="number">7</span>) * <span class="number">5</span></span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([ <span class="number">9.64213524</span>, <span class="number">-6.21912641</span>, <span class="number">-1.22788609</span>, <span class="number">-6.05784568</span>, <span class="number">-3.1042994</span> ,</span><br><span class="line">       <span class="number">-8.00085824</span>,  <span class="number">6.61050259</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">remainder, whole_part = np.modf(arr)</span><br><span class="line">remainder</span><br><span class="line"></span><br><span class="line">array([ <span class="number">0.64213524</span>, <span class="number">-0.21912641</span>, <span class="number">-0.22788609</span>, <span class="number">-0.05784568</span>, <span class="number">-0.1042994</span> ,</span><br><span class="line">       <span class="number">-0.00085824</span>,  <span class="number">0.61050259</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whole_part</span><br><span class="line"></span><br><span class="line">array([ <span class="number">9.</span>, <span class="number">-6.</span>, <span class="number">-1.</span>, <span class="number">-6.</span>, <span class="number">-3.</span>, <span class="number">-8.</span>,  <span class="number">6.</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ufuncs可以接受一个out可选参数，这样就能在数组原地进行操作：</span></span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([ <span class="number">9.64213524</span>, <span class="number">-6.21912641</span>, <span class="number">-1.22788609</span>, <span class="number">-6.05784568</span>, <span class="number">-3.1042994</span> ,</span><br><span class="line">       <span class="number">-8.00085824</span>,  <span class="number">6.61050259</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(arr)</span><br><span class="line"></span><br><span class="line">//anaconda3/lib/python3<span class="number">.7</span>/site-packages/ipykernel_launcher.py:<span class="number">1</span>: RuntimeWarning: invalid value encountered <span class="keyword">in</span> sqrt</span><br><span class="line">  <span class="string">"""Entry point for launching an IPython kernel."""</span></span><br><span class="line">  </span><br><span class="line">array([<span class="number">3.10517878</span>,        nan,        nan,        nan,        nan,</span><br><span class="line">              nan, <span class="number">2.57108977</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(arr,arr)</span><br><span class="line"></span><br><span class="line">//anaconda3/lib/python3<span class="number">.7</span>/site-packages/ipykernel_launcher.py:<span class="number">1</span>: RuntimeWarning: invalid value encountered <span class="keyword">in</span> sqrt</span><br><span class="line">  <span class="string">"""Entry point for launching an IPython kernel."""</span></span><br><span class="line"></span><br><span class="line">array([<span class="number">3.10517878</span>,        nan,        nan,        nan,        nan,</span><br><span class="line">              nan, <span class="number">2.57108977</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([<span class="number">3.10517878</span>,        nan,        nan,        nan,        nan,</span><br><span class="line">              nan, <span class="number">2.57108977</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表4-3和表4-4分别列出了一些一元和二元ufunc。</span></span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.robbyml.com/7178691-1d494e73b61c7ced.png" alt></p>
<p><img src="http://qiniu.robbyml.com/7178691-4e38d02a66481530.png" alt></p>
<p><img src="http://qiniu.robbyml.com/7178691-eff1e61e5464159f.png" alt></p>
<h5 id="4-3-利用数组进行数据处理"><a href="#4-3-利用数组进行数据处理" class="headerlink" title="4.3 利用数组进行数据处理"></a>4.3 利用数组进行数据处理</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NumPy数组使你可以将许多种数据处理任务表述为简洁的数组表达式（否则需要编写循环）。用数组表达式代替循环的做法，</span></span><br><span class="line"><span class="comment"># 通常被称为矢量化。一般来说，矢量化数组运算要比等价的纯Python方式快上一两个数量级（甚至更多），尤其是各种数</span></span><br><span class="line"><span class="comment"># 值计算。在后面内容中（见附录A）我将介绍广播，这是一种针对矢量化计算的强大手段。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 作为简单的例子，假设我们想要在一组值（网格型）上计算函数sqrt(x^2+y^2)。np.meshgrid函数接受两个一维数组，</span></span><br><span class="line"><span class="comment"># 并产生两个二维矩阵（对应于两个数组中所有的(x,y)对）：</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">points = np.arange(<span class="number">-5</span>,<span class="number">5</span>,<span class="number">0.01</span>) <span class="comment"># 1000 equally spaced points</span></span><br><span class="line">xs, ys = np.meshgrid(points, points)</span><br><span class="line">ys</span><br><span class="line"></span><br><span class="line">array([[<span class="number">-5.</span>  , <span class="number">-5.</span>  , <span class="number">-5.</span>  , ..., <span class="number">-5.</span>  , <span class="number">-5.</span>  , <span class="number">-5.</span>  ],</span><br><span class="line">       [<span class="number">-4.99</span>, <span class="number">-4.99</span>, <span class="number">-4.99</span>, ..., <span class="number">-4.99</span>, <span class="number">-4.99</span>, <span class="number">-4.99</span>],</span><br><span class="line">       [<span class="number">-4.98</span>, <span class="number">-4.98</span>, <span class="number">-4.98</span>, ..., <span class="number">-4.98</span>, <span class="number">-4.98</span>, <span class="number">-4.98</span>],</span><br><span class="line">       ...,</span><br><span class="line">       [ <span class="number">4.97</span>,  <span class="number">4.97</span>,  <span class="number">4.97</span>, ...,  <span class="number">4.97</span>,  <span class="number">4.97</span>,  <span class="number">4.97</span>],</span><br><span class="line">       [ <span class="number">4.98</span>,  <span class="number">4.98</span>,  <span class="number">4.98</span>, ...,  <span class="number">4.98</span>,  <span class="number">4.98</span>,  <span class="number">4.98</span>],</span><br><span class="line">       [ <span class="number">4.99</span>,  <span class="number">4.99</span>,  <span class="number">4.99</span>, ...,  <span class="number">4.99</span>,  <span class="number">4.99</span>,  <span class="number">4.99</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现在，对该函数的求值运算就好办了，把这两个数组当做两个浮点数那样编写表达式即可：</span></span><br><span class="line">z = np.sqrt(xs ** <span class="number">2</span> + ys ** <span class="number">2</span>)</span><br><span class="line">z</span><br><span class="line"></span><br><span class="line">array([[<span class="number">7.07106781</span>, <span class="number">7.06400028</span>, <span class="number">7.05693985</span>, ..., <span class="number">7.04988652</span>, <span class="number">7.05693985</span>,</span><br><span class="line">        <span class="number">7.06400028</span>],</span><br><span class="line">       [<span class="number">7.06400028</span>, <span class="number">7.05692568</span>, <span class="number">7.04985815</span>, ..., <span class="number">7.04279774</span>, <span class="number">7.04985815</span>,</span><br><span class="line">        <span class="number">7.05692568</span>],</span><br><span class="line">       [<span class="number">7.05693985</span>, <span class="number">7.04985815</span>, <span class="number">7.04278354</span>, ..., <span class="number">7.03571603</span>, <span class="number">7.04278354</span>,</span><br><span class="line">        <span class="number">7.04985815</span>],</span><br><span class="line">       ...,</span><br><span class="line">       [<span class="number">7.04988652</span>, <span class="number">7.04279774</span>, <span class="number">7.03571603</span>, ..., <span class="number">7.0286414</span> , <span class="number">7.03571603</span>,</span><br><span class="line">        <span class="number">7.04279774</span>],</span><br><span class="line">       [<span class="number">7.05693985</span>, <span class="number">7.04985815</span>, <span class="number">7.04278354</span>, ..., <span class="number">7.03571603</span>, <span class="number">7.04278354</span>,</span><br><span class="line">        <span class="number">7.04985815</span>],</span><br><span class="line">       [<span class="number">7.06400028</span>, <span class="number">7.05692568</span>, <span class="number">7.04985815</span>, ..., <span class="number">7.04279774</span>, <span class="number">7.04985815</span>,</span><br><span class="line">        <span class="number">7.05692568</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 作为第9章的先导，我用matplotlib创建了这个二维数组的可视化：</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(z,cmap=plt.cm.gray); plt.colorbar()</span><br><span class="line">plt.title(<span class="string">'Image plot of $\sqrt&#123;x^2 + y^2&#125;$ for a grid of values'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>Text(0.5, 1.0, &apos;Image plot of $\\sqrt{x^2 + y^2}$ for a grid of values&apos;)</code></pre><p><img src="%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89_files/%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89_126_1.png" alt="png"></p>
<h6 id="将条件逻辑表述为数组运算"><a href="#将条件逻辑表述为数组运算" class="headerlink" title="将条件逻辑表述为数组运算"></a>将条件逻辑表述为数组运算</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># numpy.where函数是三元表达式x if condition else y的矢量化版本。假设我们有一个布尔数组和两个值数组：</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xarr = np.array([<span class="number">1.1</span>,<span class="number">1.2</span>,<span class="number">1.3</span>,<span class="number">1.4</span>,<span class="number">1.5</span>])</span><br><span class="line">yarr = np.array([<span class="number">2.1</span>,<span class="number">2.2</span>,<span class="number">2.3</span>,<span class="number">2.4</span>,<span class="number">2.5</span>])</span><br><span class="line">cond = np.array([<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">False</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设我们想要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取。</span></span><br><span class="line"><span class="comment"># 列表推导式的写法应该如下所示：</span></span><br><span class="line">result = [(x <span class="keyword">if</span> c <span class="keyword">else</span> y)</span><br><span class="line">          <span class="keyword">for</span> x,y,c <span class="keyword">in</span> zip(xarr,yarr,cond)]</span><br><span class="line">result</span><br><span class="line"></span><br><span class="line">[<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">2.5</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这有几个问题。第一，它对大数组的处理速度不是很快（因为所有工作都是由纯Python完成的）。第二，无法用于多维数组。</span></span><br><span class="line"><span class="comment"># 若使用np.where，则可以将该功能写得非常简洁：</span></span><br><span class="line">result = np.where(cond, xarr, yarr)</span><br><span class="line">result</span><br><span class="line"></span><br><span class="line">array([<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">2.5</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.where的第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，where通常用于根据另一个数组</span></span><br><span class="line"><span class="comment"># 而产生一个新的数组。假设有一个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为－2。</span></span><br><span class="line"><span class="comment"># 若利用np.where，则会非常简单：</span></span><br><span class="line">arr = np.random.randn(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">1.48909871</span>, <span class="number">-0.25795826</span>,  <span class="number">1.4524639</span> ,  <span class="number">0.76421485</span>],</span><br><span class="line">       [<span class="number">-0.63415798</span>,  <span class="number">1.58407459</span>, <span class="number">-0.0506955</span> ,  <span class="number">0.44225834</span>],</span><br><span class="line">       [<span class="number">-0.49862728</span>,  <span class="number">0.7442221</span> , <span class="number">-0.39679475</span>, <span class="number">-0.22136133</span>],</span><br><span class="line">       [<span class="number">-0.31594414</span>, <span class="number">-0.37349352</span>, <span class="number">-0.84785731</span>, <span class="number">-0.70731656</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">array([[ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">       [<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">       [<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, <span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">2</span>, <span class="number">-2</span>,  <span class="number">2</span>,  <span class="number">2</span>],</span><br><span class="line">       [<span class="number">-2</span>,  <span class="number">2</span>, <span class="number">-2</span>,  <span class="number">2</span>],</span><br><span class="line">       [<span class="number">-2</span>,  <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>],</span><br><span class="line">       [<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用np.where，可以将标量和数组结合起来。例如，我可用常数2替换arr中所有正的值：</span></span><br><span class="line">np.where(arr &gt; <span class="number">0</span>,<span class="number">2</span>,arr) <span class="comment"># set only positive values to 2</span></span><br><span class="line"></span><br><span class="line">array([[ <span class="number">2.</span>        , <span class="number">-0.25795826</span>,  <span class="number">2.</span>        ,  <span class="number">2.</span>        ],</span><br><span class="line">       [<span class="number">-0.63415798</span>,  <span class="number">2.</span>        , <span class="number">-0.0506955</span> ,  <span class="number">2.</span>        ],</span><br><span class="line">       [<span class="number">-0.49862728</span>,  <span class="number">2.</span>        , <span class="number">-0.39679475</span>, <span class="number">-0.22136133</span>],</span><br><span class="line">       [<span class="number">-0.31594414</span>, <span class="number">-0.37349352</span>, <span class="number">-0.84785731</span>, <span class="number">-0.70731656</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传递给where的数组大小可以不相等，甚至可以是标量值。</span></span><br></pre></td></tr></table></figure>

<h6 id="数学和统计方法"><a href="#数学和统计方法" class="headerlink" title="数学和统计方法"></a>数学和统计方法</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。sum、mean以及标准差std等聚合</span></span><br><span class="line"><span class="comment"># 计算（aggregation，通常叫做约简（reduction））既可以当做数组的实例方法调用，也可以当做顶级NumPy函数使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里，我生成了一些正态分布随机数据，然后做了聚类统计：</span></span><br><span class="line">arr = np.random.randn(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">0.39304435</span>, <span class="number">-2.27121755</span>, <span class="number">-0.3428365</span> ,  <span class="number">1.10053606</span>],</span><br><span class="line">       [ <span class="number">0.66849674</span>,  <span class="number">0.51474167</span>,  <span class="number">0.48158182</span>, <span class="number">-0.27815047</span>],</span><br><span class="line">       [ <span class="number">0.95503521</span>, <span class="number">-0.17103106</span>, <span class="number">-1.55609134</span>,  <span class="number">2.39879377</span>],</span><br><span class="line">       [ <span class="number">1.16991334</span>, <span class="number">-1.70721878</span>, <span class="number">-0.86931691</span>, <span class="number">-0.22836694</span>],</span><br><span class="line">       [ <span class="number">1.1061178</span> ,  <span class="number">0.5632517</span> , <span class="number">-0.30284059</span>, <span class="number">-0.59106316</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.mean()</span><br><span class="line"></span><br><span class="line"><span class="number">0.05166895810634551</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.mean(arr)</span><br><span class="line"></span><br><span class="line"><span class="number">0.05166895810634551</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.sum()</span><br><span class="line"></span><br><span class="line"><span class="number">1.0333791621269102</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mean和sum这类的函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个少一维的数组：</span></span><br><span class="line">arr.mean(axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">array([<span class="number">-0.28011841</span>,  <span class="number">0.34666744</span>,  <span class="number">0.40667665</span>, <span class="number">-0.40874732</span>,  <span class="number">0.19386643</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.sum(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">array([ <span class="number">4.29260744</span>, <span class="number">-3.07147402</span>, <span class="number">-2.58950352</span>,  <span class="number">2.40174927</span>])</span><br></pre></td></tr></table></figure>

<pre><code># 这里，arr.mean(1)是“计算行的平均值”，arr.sum(0)是“计算每列的和”。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他如cumsum和cumprod之类的方法则不聚合，而是产生一个由中间结果组成的数组：</span></span><br><span class="line">arr = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br><span class="line">arr.cumsum()</span><br><span class="line"></span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在多维数组中，累加函数（如cumsum）返回的是同样大小的数组，但是会根据每个低维的切片沿着标记轴计算部分聚类：</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.cumsum(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.cumsum(axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">7</span>, <span class="number">12</span>],</span><br><span class="line">       [ <span class="number">6</span>, <span class="number">13</span>, <span class="number">21</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表4-5列出了全部的基本数组统计方法。后续章节中有很多例子都会用到这些方法。</span></span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.robbyml.com/7178691-a6c6df3ca8e0b98e.png" alt></p>
<p><img src="http://qiniu.robbyml.com/7178691-866fcde885b1d357.png" alt></p>
<h6 id="用于布尔型数组的方法"><a href="#用于布尔型数组的方法" class="headerlink" title="用于布尔型数组的方法"></a>用于布尔型数组的方法</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在上面这些方法中，布尔值会被强制转换为1（True）和0（False）。因此，sum经常被用来对布尔型数组中的True值计数：</span></span><br><span class="line">arr = np.random.randn(<span class="number">100</span>)</span><br><span class="line">(arr &gt; <span class="number">0</span>).sum() <span class="comment"># Number of positive values</span></span><br><span class="line"></span><br><span class="line"><span class="number">53</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 另外还有两个方法any和all，它们对布尔型数组非常有用。any用于测试数组中是否存在一个或多个True，</span></span><br><span class="line"><span class="comment"># 而all则检查数组中所有值是否都是True：</span></span><br><span class="line">bools = np.array([<span class="literal">False</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">False</span>])</span><br><span class="line">bools.any()</span><br><span class="line"></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bools.all()</span><br><span class="line"></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这两个方法也能用于非布尔型数组，所有非0元素将会被当做True。</span></span><br></pre></td></tr></table></figure>

<h6 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跟Python内置的列表类型一样，NumPy数组也可以通过sort方法就地排序：</span></span><br><span class="line">arr = np.random.randn(<span class="number">6</span>)</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([<span class="number">-1.60590157</span>, <span class="number">-1.00205295</span>,  <span class="number">0.2497033</span> ,  <span class="number">1.53246938</span>,  <span class="number">0.82985738</span>,</span><br><span class="line">        <span class="number">0.04033644</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.sort()</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([<span class="number">-1.60590157</span>, <span class="number">-1.00205295</span>,  <span class="number">0.04033644</span>,  <span class="number">0.2497033</span> ,  <span class="number">0.82985738</span>,</span><br><span class="line">        <span class="number">1.53246938</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort即可：</span></span><br><span class="line">arr = np.random.randn(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([[<span class="number">-0.91546841</span>, <span class="number">-0.51013772</span>, <span class="number">-0.15540535</span>],</span><br><span class="line">       [ <span class="number">0.34423729</span>, <span class="number">-0.80886391</span>,  <span class="number">0.32671235</span>],</span><br><span class="line">       [<span class="number">-1.36491951</span>,  <span class="number">0.91999699</span>, <span class="number">-0.08593928</span>],</span><br><span class="line">       [ <span class="number">1.69445162</span>, <span class="number">-0.58140902</span>, <span class="number">-0.58374825</span>],</span><br><span class="line">       [ <span class="number">1.91418765</span>, <span class="number">-1.21946522</span>, <span class="number">-0.32133918</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(<span class="number">1</span>)</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line">array([[<span class="number">-0.91546841</span>, <span class="number">-0.51013772</span>, <span class="number">-0.15540535</span>],</span><br><span class="line">       [<span class="number">-0.80886391</span>,  <span class="number">0.32671235</span>,  <span class="number">0.34423729</span>],</span><br><span class="line">       [<span class="number">-1.36491951</span>, <span class="number">-0.08593928</span>,  <span class="number">0.91999699</span>],</span><br><span class="line">       [<span class="number">-0.58374825</span>, <span class="number">-0.58140902</span>,  <span class="number">1.69445162</span>],</span><br><span class="line">       [<span class="number">-1.21946522</span>, <span class="number">-0.32133918</span>,  <span class="number">1.91418765</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顶级方法np.sort返回的是数组的已排序副本，而就地排序则会修改数组本身。计算数组分位数最简单的办法是对其进行排序，</span></span><br><span class="line"><span class="comment"># 然后选取特定位置的值：</span></span><br><span class="line">large_arr = np.random.randn(<span class="number">1000</span>)</span><br><span class="line">large_arr.sort()</span><br><span class="line">large_arr[int(<span class="number">0.05</span> * len(large_arr))] <span class="comment"># 5% quantile</span></span><br><span class="line"></span><br><span class="line"><span class="number">-1.677477289765611</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更多关于NumPy排序方法以及诸如间接排序之类的高级技术，请参阅附录A。在pandas中还可以找到一些其他跟排序有关</span></span><br><span class="line"><span class="comment"># 的数据操作（比如根据一列或多列对表格型数据进行排序）。</span></span><br></pre></td></tr></table></figure>

<h6 id="唯一化以及其它的集合逻辑"><a href="#唯一化以及其它的集合逻辑" class="headerlink" title="唯一化以及其它的集合逻辑"></a>唯一化以及其它的集合逻辑</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NumPy提供了一些针对一维ndarray的基本集合运算。最常用的可能要数np.unique了，它用于找出数组中的唯一值并</span></span><br><span class="line"><span class="comment"># 返回已排序的结果：</span></span><br><span class="line">names = np.array([<span class="string">'Bob'</span>,<span class="string">'Joe'</span>,<span class="string">'Will'</span>,<span class="string">'Bob'</span>,<span class="string">'Will'</span>,<span class="string">'Joe'</span>,<span class="string">'Joe'</span>])</span><br><span class="line">np.unique(names)</span><br><span class="line"></span><br><span class="line">array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>], dtype=<span class="string">'&lt;U4'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ints = np.array([<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br><span class="line">np.unique(ints)</span><br><span class="line"></span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拿跟np.unique等价的纯Python代码来对比一下：</span></span><br><span class="line">sorted(set(names))</span><br><span class="line"></span><br><span class="line">[<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 另一个函数np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组：</span></span><br><span class="line">values = np.array([<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">np.in1d(values,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">array([ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NumPy中的集合函数请参见表4-6</span></span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.robbyml.com/7178691-80e85ae6b9c89ada.png" alt></p>
<h5 id="4-4-用于数组的文件输入输出"><a href="#4-4-用于数组的文件输入输出" class="headerlink" title="4.4  用于数组的文件输入输出"></a>4.4  用于数组的文件输入输出</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NumPy能够读写磁盘上的文本数据或二进制数据。这一小节只讨论NumPy的内置二进制格式，因为更多的用户会</span></span><br><span class="line"><span class="comment"># 使用pandas或其它工具加载文本或表格数据（见第6章）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在</span></span><br><span class="line"><span class="comment"># 扩展名为.npy的文件中的：</span></span><br><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">np.save(<span class="string">'some_array'</span>,arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上。然后就可以通过np.load读取磁盘上的数组：</span></span><br><span class="line">np.load(<span class="string">'some_array.npy'</span>)</span><br><span class="line"></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过np.savez可以将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入即可：</span></span><br><span class="line">np.savez(<span class="string">'array_archive.npz'</span>,a=arr,b=arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载.npz文件时，你会得到一个类似字典的对象，该对象会对各个数组进行延迟加载：</span></span><br><span class="line">arch = np.load(<span class="string">'array_archive.npz'</span>)</span><br><span class="line">arch[<span class="string">'b'</span>]</span><br><span class="line"></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果要将数据压缩，可以使用numpy.savez_compressed：</span></span><br><span class="line">np.savez_compressed(<span class="string">'arrayscompressed.npz'</span>,a=arr,b=arr)</span><br></pre></td></tr></table></figure>

<h5 id="4-5-线性代数"><a href="#4-5-线性代数" class="headerlink" title="4.5 线性代数"></a>4.5 线性代数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线性代数（如矩阵乘法、矩阵分解、行列式以及其他方阵数学等）是任何数组库的重要组成部分。不像某些语言（如MATLAB），</span></span><br><span class="line"><span class="comment"># 通过*对两个二维数组相乘得到的是一个元素级的积，而不是一个矩阵点积。因此，NumPy提供了一个用于矩阵乘法的dot函数</span></span><br><span class="line"><span class="comment"># （既是一个数组方法也是numpy命名空间中的一个函数）：</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>],[<span class="number">4.</span>,<span class="number">5.</span>,<span class="number">6.</span>]])</span><br><span class="line">y = np.array([[<span class="number">6.</span>,<span class="number">23.</span>],[<span class="number">-1</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">9</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x</span><br><span class="line"></span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">y</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">6.</span>, <span class="number">23.</span>],</span><br><span class="line">       [<span class="number">-1.</span>,  <span class="number">7.</span>],</span><br><span class="line">       [ <span class="number">8.</span>,  <span class="number">9.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x.dot(y)</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">28.</span>,  <span class="number">64.</span>],</span><br><span class="line">       [ <span class="number">67.</span>, <span class="number">181.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x.dot(y)等价于np.dot(x, y)：</span></span><br><span class="line">np.dot(x,y)</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">28.</span>,  <span class="number">64.</span>],</span><br><span class="line">       [ <span class="number">67.</span>, <span class="number">181.</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个二维数组跟一个大小合适的一维数组的矩阵点积运算之后将会得到一个一维数组：</span></span><br><span class="line">np.dot(x,np.ones(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">array([ <span class="number">6.</span>, <span class="number">15.</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @符（类似Python 3.5）也可以用作中缀运算符，进行矩阵乘法：</span></span><br><span class="line">x @ np.ones(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">array([ <span class="number">6.</span>, <span class="number">15.</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># numpy.linalg中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。它们跟MATLAB和R等语言所使用的是相同的</span></span><br><span class="line"><span class="comment"># 行业标准线性代数库，如BLAS、LAPACK、Intel MKL（Math Kernel Library，可能有，取决于你的NumPy版本）等：</span></span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv, qr</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.randn(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">mat = x.T.dot(x)</span><br><span class="line">inv(mat)</span><br><span class="line"></span><br><span class="line">array([[  <span class="number">3.48504634</span>,   <span class="number">7.37627575</span>,  <span class="number">-5.76553763</span>,  <span class="number">-0.89397434</span>,</span><br><span class="line">         <span class="number">-7.87805442</span>],</span><br><span class="line">       [  <span class="number">7.37627575</span>,  <span class="number">16.32127968</span>, <span class="number">-12.43837442</span>,  <span class="number">-2.02447857</span>,</span><br><span class="line">        <span class="number">-17.09373335</span>],</span><br><span class="line">       [ <span class="number">-5.76553763</span>, <span class="number">-12.43837442</span>,   <span class="number">9.81814105</span>,   <span class="number">1.60545579</span>,</span><br><span class="line">         <span class="number">13.20146794</span>],</span><br><span class="line">       [ <span class="number">-0.89397434</span>,  <span class="number">-2.02447857</span>,   <span class="number">1.60545579</span>,   <span class="number">0.47930201</span>,</span><br><span class="line">          <span class="number">2.08681938</span>],</span><br><span class="line">       [ <span class="number">-7.87805442</span>, <span class="number">-17.09373335</span>,  <span class="number">13.20146794</span>,   <span class="number">2.08681938</span>,</span><br><span class="line">         <span class="number">18.22091922</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mat.dot(inv(mat))</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">1.00000000e+00</span>, <span class="number">-3.65392288e-15</span>, <span class="number">-1.36535987e-15</span>,</span><br><span class="line">        <span class="number">-1.84827838e-15</span>,  <span class="number">1.87633793e-15</span>],</span><br><span class="line">       [ <span class="number">6.19605210e-15</span>,  <span class="number">1.00000000e+00</span>,  <span class="number">3.18560644e-15</span>,</span><br><span class="line">         <span class="number">1.41093674e-15</span>, <span class="number">-7.94000314e-15</span>],</span><br><span class="line">       [ <span class="number">9.64362720e-17</span>, <span class="number">-5.86542060e-15</span>,  <span class="number">1.00000000e+00</span>,</span><br><span class="line">        <span class="number">-2.48962929e-16</span>,  <span class="number">2.05572058e-15</span>],</span><br><span class="line">       [ <span class="number">3.23129097e-15</span>,  <span class="number">4.65522943e-15</span>,  <span class="number">2.22247747e-16</span>,</span><br><span class="line">         <span class="number">1.00000000e+00</span>, <span class="number">-2.38002484e-15</span>],</span><br><span class="line">       [<span class="number">-1.43036574e-16</span>, <span class="number">-9.32929257e-15</span>,  <span class="number">2.02115359e-14</span>,</span><br><span class="line">         <span class="number">1.72381743e-15</span>,  <span class="number">1.00000000e+00</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">q,r = qr(mat)</span><br><span class="line">r</span><br><span class="line"></span><br><span class="line">array([[<span class="number">-18.27162442</span>,  <span class="number">-2.54580749</span>,  <span class="number">-6.00444905</span>,   <span class="number">2.87378633</span>,</span><br><span class="line">         <span class="number">-6.28246201</span>],</span><br><span class="line">       [  <span class="number">0.</span>        ,  <span class="number">-4.88007596</span>,   <span class="number">1.37466008</span>,  <span class="number">-2.47305306</span>,</span><br><span class="line">         <span class="number">-5.32230967</span>],</span><br><span class="line">       [  <span class="number">0.</span>        ,   <span class="number">0.</span>        ,  <span class="number">-5.47622132</span>,   <span class="number">2.94707858</span>,</span><br><span class="line">          <span class="number">3.65163246</span>],</span><br><span class="line">       [  <span class="number">0.</span>        ,   <span class="number">0.</span>        ,   <span class="number">0.</span>        ,  <span class="number">-4.02022414</span>,</span><br><span class="line">          <span class="number">0.47350064</span>],</span><br><span class="line">       [  <span class="number">0.</span>        ,   <span class="number">0.</span>        ,   <span class="number">0.</span>        ,   <span class="number">0.</span>        ,</span><br><span class="line">          <span class="number">0.03400309</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表达式X.T.dot(X)计算X和它的转置X.T的点积。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表4-7中列出了一些最常用的线性代数函数。</span></span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.robbyml.com/7178691-dcdb66e49e5f70ea.png" alt></p>
<h5 id="4-6-伪随机数生成"><a href="#4-6-伪随机数生成" class="headerlink" title="4.6 伪随机数生成"></a>4.6 伪随机数生成</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># numpy.random模块对Python内置的random进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数。</span></span><br><span class="line"><span class="comment"># 例如，你可以用normal来得到一个标准正态分布的4×4样本数组：</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">samples = np.random.normal(size=(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line">samples</span><br><span class="line"></span><br><span class="line">array([[ <span class="number">1.15439072</span>,  <span class="number">1.30988813</span>,  <span class="number">0.16310176</span>, <span class="number">-0.62632784</span>],</span><br><span class="line">       [<span class="number">-0.35183032</span>, <span class="number">-1.1387066</span> ,  <span class="number">1.3372165</span> ,  <span class="number">0.47846892</span>],</span><br><span class="line">       [ <span class="number">1.3382341</span> ,  <span class="number">0.17211005</span>, <span class="number">-0.31101723</span>,  <span class="number">0.06567243</span>],</span><br><span class="line">       [<span class="number">-0.05308368</span>, <span class="number">-2.35290215</span>, <span class="number">-1.21574325</span>,  <span class="number">0.01104934</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 而Python内置的random模块则只能一次生成一个样本值。从下面的测试结果中可以看出，如果需要产生大量样本值，</span></span><br><span class="line"><span class="comment"># numpy.random快了不止一个数量级：</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> normalvariate</span><br><span class="line">N = <span class="number">1000000</span></span><br><span class="line">%timeit samples = [normalvariate(<span class="number">0</span>,<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"></span><br><span class="line"><span class="number">592</span> ms ± <span class="number">18.3</span> ms per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1</span> loop each)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%timeit np.random.normal(size=N)</span><br><span class="line"></span><br><span class="line"><span class="number">25.4</span> ms ± <span class="number">240</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10</span> loops each)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们说这些都是伪随机数，是因为它们都是通过算法基于随机数生成器种子，在确定性的条件下生成的。你可以用NumPy的</span></span><br><span class="line"><span class="comment"># np.random.seed更改随机数生成种子：</span></span><br><span class="line">np.random.seed(<span class="number">1234</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">1234</span>)</span><br><span class="line">rng.randn(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">array([ <span class="number">0.47143516</span>, <span class="number">-1.19097569</span>,  <span class="number">1.43270697</span>, <span class="number">-0.3126519</span> , <span class="number">-0.72058873</span>,</span><br><span class="line">        <span class="number">0.88716294</span>,  <span class="number">0.85958841</span>, <span class="number">-0.6365235</span> ,  <span class="number">0.01569637</span>, <span class="number">-2.24268495</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表4-8列出了numpy.random中的部分函数。在下一节中，我将给出一些利用这些函数一次性生成大量样本值的范例。</span></span><br></pre></td></tr></table></figure>

<p><img src="http://qiniu.robbyml.com/7178691-97ba09c96dab93a2.png" alt></p>
<p><img src="http://qiniu.robbyml.com/7178691-97ba09c96dab93a2.png" alt></p>
<h5 id="4-7-示例：随机漫步"><a href="#4-7-示例：随机漫步" class="headerlink" title="4.7 示例：随机漫步"></a>4.7 示例：随机漫步</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们通过模拟随机漫步来说明如何运用数组运算。先来看一个简单的随机漫步的例子：从0开始，步长1和－1出现的概率相等。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面是一个通过内置的random模块以纯Python的方式实现1000步的随机漫步：</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">position = <span class="number">0</span></span><br><span class="line">walk = [position]</span><br><span class="line">steps = <span class="number">1000</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(steps):</span><br><span class="line">    step = <span class="number">1</span> <span class="keyword">if</span> random.randint(<span class="number">0</span>,<span class="number">1</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    position += step</span><br><span class="line">    walk.append(position)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图4-4是根据前100个随机漫步值生成的折线图：</span></span><br><span class="line">plt.plot(walk[:<span class="number">100</span>])</span><br><span class="line"></span><br><span class="line">[&lt;matplotlib.lines.Line2D at <span class="number">0x126efdcf8</span>&gt;]</span><br></pre></td></tr></table></figure>

<p><img src="%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89_files/%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89_196_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不难看出，这其实就是随机漫步中各步的累计和，可以用一个数组运算来实现。因此，我用np.random模块一次性随机</span></span><br><span class="line"><span class="comment"># 产生1000个“掷硬币”结果（即两个数中任选一个），将其分别设置为1或－1，然后计算累计和：</span></span><br><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,size=nsteps)</span><br><span class="line">steps = np.where(draws &gt; <span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">walk = steps.cumsum()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有了这些数据之后，我们就可以沿着漫步路径做一些统计工作了，比如求取最大值和最小值：</span></span><br><span class="line">walk.min()</span><br><span class="line"></span><br><span class="line"><span class="number">-9</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">walk.max()</span><br><span class="line"></span><br><span class="line"><span class="number">60</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现在来看一个复杂点的统计任务——首次穿越时间，即随机漫步过程中第一次到达某个特定值的时间。假设我们想要知道本次</span></span><br><span class="line"><span class="comment"># 随机漫步需要多久才能距离初始0点至少10步远（任一方向均可）。np.abs(walk)&gt;=10可以得到一个布尔型数组，它表示</span></span><br><span class="line"><span class="comment"># 的是距离是否达到或超过10，而我们想要知道的是第一个10或－10的索引。可以用argmax来解决这个问题，它返回的是该</span></span><br><span class="line"><span class="comment"># 布尔型数组第一个最大值的索引（True就是最大值）：</span></span><br><span class="line">(np.abs(walk) &gt;= <span class="number">10</span>).argmax()</span><br><span class="line"></span><br><span class="line"><span class="number">297</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，这里使用argmax并不是很高效，因为它无论如何都会对数组进行完全扫描。在本例中，只要发现了一个True，</span></span><br><span class="line"><span class="comment"># 那我们就知道它是个最大值了。</span></span><br></pre></td></tr></table></figure>

<h6 id="一次模拟多个随机漫步"><a href="#一次模拟多个随机漫步" class="headerlink" title="一次模拟多个随机漫步"></a>一次模拟多个随机漫步</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你希望模拟多个随机漫步过程（比如5000个），只需对上面的代码做一点点修改即可生成所有的随机漫步过程。</span></span><br><span class="line"><span class="comment"># 只要给numpy.random的函数传入一个二元元组就可以产生一个二维数组，然后我们就可以一次性计算5000个随机漫步过程（</span></span><br><span class="line"><span class="comment"># 一行一个）的累计和了：</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nwalks = <span class="number">5000</span></span><br><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,size=(nwalks,nsteps)) <span class="comment"># 0 or 1</span></span><br><span class="line">steps = np.where(draws &gt; <span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">walks = steps.cumsum(<span class="number">1</span>)</span><br><span class="line">walks</span><br><span class="line"></span><br><span class="line">array([[  <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">3</span>, ...,  <span class="number">46</span>,  <span class="number">47</span>,  <span class="number">46</span>],</span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>, ...,  <span class="number">40</span>,  <span class="number">41</span>,  <span class="number">42</span>],</span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">3</span>, ..., <span class="number">-26</span>, <span class="number">-27</span>, <span class="number">-28</span>],</span><br><span class="line">       ...,</span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>, ...,  <span class="number">64</span>,  <span class="number">65</span>,  <span class="number">66</span>],</span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">1</span>, ...,   <span class="number">2</span>,   <span class="number">1</span>,   <span class="number">0</span>],</span><br><span class="line">       [ <span class="number">-1</span>,  <span class="number">-2</span>,  <span class="number">-3</span>, ...,  <span class="number">32</span>,  <span class="number">33</span>,  <span class="number">34</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现在，我们来计算所有随机漫步过程的最大值和最小值：</span></span><br><span class="line">walks.max()</span><br><span class="line"></span><br><span class="line"><span class="number">122</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">walks.min()</span><br><span class="line"></span><br><span class="line"><span class="number">-128</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到这些数据之后，我们来计算30或－30的最小穿越时间。这里稍微复杂些，因为不是5000个过程都到达了30。</span></span><br><span class="line"><span class="comment"># 我们可以用any方法来对此进行检查：</span></span><br><span class="line">hits30 = (np.abs(walks) &gt;= <span class="number">30</span>).any(<span class="number">1</span>)</span><br><span class="line">hits30</span><br><span class="line"></span><br><span class="line">array([ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, ...,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hits30.sum() <span class="comment"># Number that hit 30 or -30</span></span><br><span class="line"></span><br><span class="line"><span class="number">3368</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 然后我们利用这个布尔型数组选出那些穿越了30（绝对值）的随机漫步（行），并调用argmax在轴1上获取穿越时间：</span></span><br><span class="line">crossing_times = (np.abs(walks[hits30]) &gt;= <span class="number">30</span>).argmax(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crossing_times.mean()</span><br><span class="line"></span><br><span class="line"><span class="number">509.99762470308787</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请尝试用其他分布方式得到漫步数据。只需使用不同的随机数生成函数即可，如normal用于生成指定均值和标准差的正态分布数据：</span></span><br><span class="line">steps = np.random.normal(loc=<span class="number">0</span>,scale=<span class="number">0.25</span>,size=(nwalks,nsteps))</span><br></pre></td></tr></table></figure>

<h5 id="4-8-结论"><a href="#4-8-结论" class="headerlink" title="4.8 结论"></a>4.8 结论</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 虽然本书剩下的章节大部分是用pandas规整数据，我们还是会用到相似的基于数组的计算。在附录A中，我们会深入挖掘</span></span><br><span class="line"><span class="comment"># NumPy的特点，进一步学习数组的技巧。</span></span><br></pre></td></tr></table></figure>


  </div>
</article>



    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="vcomments" class="blog-post-comments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            visitor: true,
            appId: 'q494NdCTA7S8AuwxLVHFxz41-MdYXbMMI',
            appKey: 'dV8G37HkOGPbWVkPzlAUndh7',
            placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
            avatar: 'robohash'
        })
    </script>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#第4章-NumPy基础：数组和矢量计算"><span class="toc-number">1.</span> <span class="toc-text">第4章  NumPy基础：数组和矢量计算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-NumPy的ndarray-一种多维数组对象"><span class="toc-number">1.1.</span> <span class="toc-text">4.1 NumPy的ndarray:一种多维数组对象</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#创建ndarray"><span class="toc-number">1.1.1.</span> <span class="toc-text">创建ndarray</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ndarray的数据类型"><span class="toc-number">1.1.2.</span> <span class="toc-text">ndarray的数据类型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#NumPy数组的运算"><span class="toc-number">1.1.3.</span> <span class="toc-text">NumPy数组的运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#基本的索引和切片"><span class="toc-number">1.1.4.</span> <span class="toc-text">基本的索引和切片</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#切片索引"><span class="toc-number">1.1.5.</span> <span class="toc-text">切片索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#布尔型索引"><span class="toc-number">1.1.6.</span> <span class="toc-text">布尔型索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#花式索引"><span class="toc-number">1.1.7.</span> <span class="toc-text">花式索引</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#数组转置和轴对换"><span class="toc-number">1.1.8.</span> <span class="toc-text">数组转置和轴对换</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-通用函数：快速的元素级数组函数"><span class="toc-number">1.2.</span> <span class="toc-text">4.2 通用函数：快速的元素级数组函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-利用数组进行数据处理"><span class="toc-number">1.3.</span> <span class="toc-text">4.3 利用数组进行数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#将条件逻辑表述为数组运算"><span class="toc-number">1.3.1.</span> <span class="toc-text">将条件逻辑表述为数组运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#数学和统计方法"><span class="toc-number">1.3.2.</span> <span class="toc-text">数学和统计方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#用于布尔型数组的方法"><span class="toc-number">1.3.3.</span> <span class="toc-text">用于布尔型数组的方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#排序"><span class="toc-number">1.3.4.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#唯一化以及其它的集合逻辑"><span class="toc-number">1.3.5.</span> <span class="toc-text">唯一化以及其它的集合逻辑</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-用于数组的文件输入输出"><span class="toc-number">1.4.</span> <span class="toc-text">4.4  用于数组的文件输入输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-线性代数"><span class="toc-number">1.5.</span> <span class="toc-text">4.5 线性代数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-伪随机数生成"><span class="toc-number">1.6.</span> <span class="toc-text">4.6 伪随机数生成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-示例：随机漫步"><span class="toc-number">1.7.</span> <span class="toc-text">4.7 示例：随机漫步</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#一次模拟多个随机漫步"><span class="toc-number">1.7.1.</span> <span class="toc-text">一次模拟多个随机漫步</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-8-结论"><span class="toc-number">1.8.</span> <span class="toc-text">4.8 结论</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&text=利用Python进行数据分析.第二版笔记（2）"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&title=利用Python进行数据分析.第二版笔记（2）"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&is_video=false&description=利用Python进行数据分析.第二版笔记（2）"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=利用Python进行数据分析.第二版笔记（2）&body=Check out this article: https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&title=利用Python进行数据分析.第二版笔记（2）"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&title=利用Python进行数据分析.第二版笔记（2）"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&title=利用Python进行数据分析.第二版笔记（2）"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&title=利用Python进行数据分析.第二版笔记（2）"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/gaojianjie412/gaojianjie412.github.io/2019/09/22/利用Python进行数据分析.第二版笔记（2）/&name=利用Python进行数据分析.第二版笔记（2）&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Robby
    <a href="http://www.beian.miit.gov.cn/">豫ICP备19040301号</a> 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/categories/">Category</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
        
    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-148159204-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb105d46eafbe9b2400ee1886ae06d2";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->


</body>
</html>
